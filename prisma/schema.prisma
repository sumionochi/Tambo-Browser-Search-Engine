// prisma/schema.prisma

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ──────────────────────────────────────────────
// EXISTING MODELS (unchanged)
// ──────────────────────────────────────────────

model User {
  id         String   @id @default(uuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  email      String   @unique
  firstName  String?
  lastName   String?
  image      String?
  supabaseId String   @unique

  // Relations
  collections     Collection[]
  calendarEvents  CalendarEvent[]
  notes           Note[]
  searchHistory   SearchHistory[]
  generatedImages GeneratedImage[]
  conversations   Conversation[]
  searchSessions  SearchSession[]
  workflows       Workflow[] // ← NEW
  reports         Report[] // ← NEW
}

model Collection {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  items     Json     @default("[]")

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  calendarEvents CalendarEvent[]
  notes          Note[]
  images         GeneratedImage[]

  @@index([userId])
}

model CalendarEvent {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String
  datetime  DateTime
  note      String?
  completed Boolean  @default(false)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  linkedCollectionId String?
  linkedCollection   Collection? @relation(fields: [linkedCollectionId], references: [id], onDelete: SetNull)

  linkedItems Json @default("[]")

  @@index([userId])
  @@index([datetime])
}

model GeneratedImage {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now())
  originalUrl String
  variations  Json     @default("[]")

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  linkedCollectionId String?
  linkedCollection   Collection? @relation(fields: [linkedCollectionId], references: [id], onDelete: SetNull)

  @@index([userId])
}

model Note {
  id           String   @id @default(uuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  content      String
  sourceSearch String?

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  linkedCollectionId String?
  linkedCollection   Collection? @relation(fields: [linkedCollectionId], references: [id], onDelete: SetNull)

  @@index([userId])
}

model SearchHistory {
  id           String   @id @default(uuid())
  createdAt    DateTime @default(now())
  query        String
  source       String // "google", "github", "pexels"
  filters      Json?
  resultsCount Int?

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

model Conversation {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  threadId  String   @unique
  name      String?
  messages  Json[]

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([updatedAt])
}

model SearchSession {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  query     String
  source    String // "pexels", "google", "github"
  results   Json // Store the actual search results

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

// ──────────────────────────────────────────────
// PHASE 3: AI WORKFLOWS — NEW MODELS
// ──────────────────────────────────────────────

/// Research Workflow — Stores the full workflow definition
/// and tracks overall execution progress.
///
/// Status lifecycle: pending → running → completed | failed
///
/// `steps` JSON structure:
/// [
///   {
///     "index": 0,
///     "type": "search" | "extract" | "analyze" | "aggregate" | "generate_report",
///     "title": "Search for React alternatives",
///     "description": "Find top React alternatives using Google",
///     "params": { "query": "React alternatives 2025", "source": "google", "num": 10 },
///     "dependsOn": []          // indices of steps this depends on
///   },
///   ...
/// ]
///
/// `results` JSON structure:
/// [
///   { "stepIndex": 0, "data": { ... } },
///   { "stepIndex": 1, "data": { ... } },
///   ...
/// ]
model Workflow {
  id          String    @id @default(uuid())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime?

  // User ownership
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Workflow metadata
  title       String // AI-generated or user-provided title
  description String? // Brief description of the research goal
  query       String // Original natural language query from user

  // Execution state
  status      String @default("pending") // "pending" | "running" | "completed" | "failed"
  currentStep Int    @default(0) // Index of the currently executing step
  totalSteps  Int    @default(0) // Total number of steps

  // Workflow definition & results
  steps   Json @default("[]") // Array of step definitions (see doc above)
  results Json @default("[]") // Array of step results, indexed by stepIndex

  // Configuration
  sources      String[] @default([]) // ["google", "github", "pexels"]
  depth        String   @default("standard") // "quick" | "standard" | "deep"
  outputFormat String   @default("summary") // "comparison" | "analysis" | "timeline" | "summary"

  // Error tracking
  errorMessage String?
  failedStep   Int? // Index of the step that failed (if any)

  // Relations
  executions WorkflowExecution[]
  report     Report?

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

/// WorkflowExecution — Individual step execution record.
/// One record per step attempt. If a step is retried, multiple
/// records can exist for the same stepIndex.
///
/// Useful for debugging, audit trail, and implementing retry logic.
model WorkflowExecution {
  id          String    @id @default(uuid())
  createdAt   DateTime  @default(now())
  completedAt DateTime?

  // Link to parent workflow
  workflowId String
  workflow   Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  // Step identification
  stepIndex Int // Which step in the workflow (0-based)
  stepType  String // "search" | "extract" | "analyze" | "aggregate" | "generate_report"
  stepTitle String @default("") // Human-readable step title

  // Execution data
  input  Json // Parameters sent to this step
  output Json? // Result data from this step (null until completed)
  status String  @default("pending") // "pending" | "running" | "completed" | "failed"
  error  String? // Error message if step failed

  // Timing
  durationMs Int? // How long this step took in milliseconds

  @@index([workflowId])
  @@index([workflowId, stepIndex])
}

/// Report — AI-generated research report from workflow results
/// or from collection synthesis.
///
/// `sections` JSON structure:
/// [
///   {
///     "id": "section-1",
///     "type": "text",
///     "title": "Executive Summary",
///     "content": "This report analyzes..."
///   },
///   {
///     "id": "section-2",
///     "type": "table",
///     "title": "Framework Comparison",
///     "content": {
///       "headers": ["Name", "Stars", "Forks", "Language"],
///       "rows": [
///         ["Vue", "220K", "35K", "TypeScript"],
///         ["Svelte", "75K", "4K", "JavaScript"]
///       ]
///     }
///   },
///   {
///     "id": "section-3",
///     "type": "chart",
///     "title": "GitHub Stars Trend",
///     "content": {
///       "chartType": "bar",
///       "labels": ["Vue", "Svelte", "Solid"],
///       "datasets": [{ "label": "Stars", "data": [220000, 75000, 30000] }]
///     }
///   },
///   {
///     "id": "section-4",
///     "type": "list",
///     "title": "Key Insights",
///     "content": {
///       "items": ["Vue has the largest community", "Svelte shows fastest growth"]
///     }
///   }
/// ]
///
/// `sourceData` JSON structure:
/// {
///   "workflowQuery": "Compare React alternatives",
///   "sources": [
///     { "type": "google", "query": "React alternatives", "resultCount": 10 },
///     { "type": "github", "query": "vue svelte solid", "resultCount": 5 }
///   ],
///   "collectionId": null
/// }
model Report {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User ownership
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Report content
  title   String // Report title
  summary String // AI-generated executive summary (2-3 sentences)

  // Structured report body
  sections Json @default("[]") // Array of typed sections (see doc above)

  // Report configuration
  format String @default("summary") // "comparison" | "analysis" | "timeline" | "summary"

  // Source references — tracks where data came from
  sourceData Json @default("{}") // References to workflows, searches, collections

  // Optional link to the workflow that generated this report
  workflowId String?   @unique
  workflow   Workflow? @relation(fields: [workflowId], references: [id], onDelete: SetNull)

  // Optional link to a collection (for reports generated from collections)
  sourceCollectionId String?

  @@index([userId])
  @@index([createdAt])
}
